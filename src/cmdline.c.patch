--- cmdline.c.ggo	2006-09-05 15:07:28.000000000 +0200
+++ cmdline.c	2006-09-05 15:07:44.000000000 +0200
@@ -1,7 +1,9 @@
 /*
   File autogenerated by gengetopt version 2.16
   generated with the following command:
-  gengetopt -C 
+
+  gengetopt -C < cmdline.ggo
+  patch -p0 < cmdline.c.patch
 
   The developers of gengetopt consider the fixed text that goes in all
   gengetopt output files to be in the public domain:
@@ -13,12 +15,8 @@
 #include "config.h"
 #endif
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
+#include "system.h"
 #include "getopt.h"
-
 #include "cmdline.h"
 
 static
@@ -53,7 +51,7 @@
   struct macallowed_list * next;
 };
 
-static char *
+char *
 gengetopt_strdup (const char *s);
 
 static
@@ -337,7 +335,7 @@
   clear_args (args_info);
 }
 
-static void
+void
 cmdline_parser_release (struct gengetopt_args_info *args_info)
 {
   
@@ -2786,55 +3006,41 @@
 #define CONFIG_FILE_LINE_BUFFER_SIZE (CONFIG_FILE_LINE_SIZE+3)
 /* 3 is for "--" and "=" */
 
-char my_argv[CONFIG_FILE_LINE_BUFFER_SIZE+1];
-
-int
-cmdline_parser_configfile (char * const filename, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
-{
-  FILE* file;
+static int
+parse_configfile (char * const filename, int *my_argc) {
+  char my_argv[CONFIG_FILE_LINE_BUFFER_SIZE+1];
+  FILE * file;
   char linebuf[CONFIG_FILE_LINE_SIZE];
   int line_num = 0;
-  int i, result, equal;
+  int result=0, equal;
   char *fopt, *farg;
   char *str_index;
   size_t len, next_token;
   char delimiter;
-  int my_argc = 0;
-  char **my_argv_arg;
-  char *additional_error;
 
-  /* store the program name */
-  cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
-  cmd_line_list_tmp->next = cmd_line_list;
-  cmd_line_list = cmd_line_list_tmp;
-  cmd_line_list->string_arg = gengetopt_strdup (CMDLINE_PARSER_PACKAGE);
-
-  if ((file = fopen(filename, "r")) == NULL)
-    {
+  if ((file = fopen(filename, "r")) == NULL) {
       fprintf (stderr, "%s: Error opening configuration file '%s'\n",
                CMDLINE_PARSER_PACKAGE, filename);
-      result = EXIT_FAILURE;
-      goto conf_failure;
+    return EXIT_FAILURE;
     }
 
-  while ((fgets(linebuf, CONFIG_FILE_LINE_SIZE, file)) != NULL)
-    {
+  while ((fgets(linebuf, CONFIG_FILE_LINE_SIZE, file)) != NULL) {
       ++line_num;
       my_argv[0] = '\0';
       len = strlen(linebuf);
-      if (len > (CONFIG_FILE_LINE_BUFFER_SIZE-1))
-        {
+    
+    if (len > (CONFIG_FILE_LINE_BUFFER_SIZE-1)) {
           fprintf (stderr, "%s:%s:%d: Line too long in configuration file\n",
                    CMDLINE_PARSER_PACKAGE, filename, line_num);
           result = EXIT_FAILURE;
-          goto conf_failure;
+      break;
         }
 
       /* find first non-whitespace character in the line */
-      next_token = strspn ( linebuf, " \t\r\n");
+    next_token = strspn (linebuf, " \t\r\n");
       str_index  = linebuf + next_token;
 
-      if ( str_index[0] == '\0' || str_index[0] == '#')
+    if (str_index[0] == '\0' || str_index[0] == '#')
         continue; /* empty line or comment line is skipped */
 
       fopt = str_index;
@@ -2855,10 +3061,10 @@
 
       /* advance pointers to the next token after the end of fopt */
       next_token += strspn (fopt + next_token, " \t\r\n");
+    
       /* check for the presence of equal sign, and if so, skip it */
-      if ( !equal )
-        if ((equal = (fopt[next_token] == '=')))
-          {
+    if (!equal)
+      if ((equal = (fopt[next_token] == '='))) {
             next_token++;
             next_token += strspn (fopt + next_token, " \t\r\n");
           }
@@ -2876,7 +3082,7 @@
                  "%s:%s:%d: unterminated string in configuration file\n",
                  CMDLINE_PARSER_PACKAGE, filename, line_num);
               result = EXIT_FAILURE;
-              goto conf_failure;
+            break;
             }
         }
       else
@@ -2894,25 +3100,30 @@
           str_index += strspn(str_index, " \t\r\n");
           if (*str_index != '\0' && *str_index != '#')
             {
-              fprintf
-                (stderr,
-                 "%s:%s:%d: malformed string in configuration file\n",
+            fprintf(stderr, "%s:%s:%d: malformed string in configuration file\n",
                  CMDLINE_PARSER_PACKAGE, filename, line_num);
               result = EXIT_FAILURE;
-              goto conf_failure;
+            break;
             }
         }
 
     noarg:
-      ++my_argc;
-      len = strlen(fopt);
+    if (!strcmp(fopt,"include")) {
+      if (farg && *farg) {
+        result = parse_configfile(farg, my_argc);
+      } else {
+        fprintf(stderr, "%s:%s:%d: include requires a filename argument.\n",
+                CMDLINE_PARSER_PACKAGE, filename, line_num);
+      }
+      continue;
+    }
 
+    len = strlen(fopt);
       strcat (my_argv, len > 1 ? "--" : "-");
       strcat (my_argv, fopt);
-      if (len > 1 && ((farg &&*farg) || equal))
-          strcat (my_argv, "=");
-      if (farg && *farg)
-          strcat (my_argv, farg);
+    if (len > 1 && ((farg && *farg) || equal)) strcat (my_argv, "=");
+    if (farg && *farg) strcat (my_argv, farg);
+    ++(*my_argc);
 
       cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
       cmd_line_list_tmp->next = cmd_line_list;
@@ -2920,31 +3131,54 @@
       cmd_line_list->string_arg = gengetopt_strdup(my_argv);
     } /* while */
 
-  ++my_argc; /* for program name */
+  if (file) fclose(file);
+  return result;
+}
+
+
+int 
+cmdline_parser_configfile (char * const filename, 
+			   struct gengetopt_args_info *args_info, int override, 
+			   int initialize, int check_required) {
+  int i, result;
+  int my_argc = 1;
+  char **my_argv_arg;
+  char *additional_error;
+
+  /* store the program name */
+  cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
+  cmd_line_list_tmp->next = cmd_line_list;
+  cmd_line_list = cmd_line_list_tmp;
+  cmd_line_list->string_arg = gengetopt_strdup (CMDLINE_PARSER_PACKAGE);
+
+  result = parse_configfile(filename, &my_argc);
+
+  if (result != EXIT_FAILURE) {
   my_argv_arg = (char **) malloc((my_argc+1) * sizeof(char *));
   cmd_line_list_tmp = cmd_line_list;
+    
   for (i = my_argc - 1; i >= 0; --i) {
     my_argv_arg[i] = cmd_line_list_tmp->string_arg;
     cmd_line_list_tmp = cmd_line_list_tmp->next;
   }
+
   my_argv_arg[my_argc] = 0;
 
   additional_error = (char *)malloc(strlen(filename) + strlen(ADDITIONAL_ERROR) + 1);
   strcpy (additional_error, ADDITIONAL_ERROR);
   strcat (additional_error, filename);
-  result =
-    cmdline_parser_internal (my_argc, my_argv_arg, args_info, override, initialize, check_required, additional_error);
+    
+    result = cmdline_parser_internal (my_argc, my_argv_arg, args_info,
+                                      override, initialize, check_required,
+                                      additional_error);
 
   free (additional_error);
   free (my_argv_arg);
+  }
 
-conf_failure:
-  if (file)
-    fclose(file);
-  if (result == EXIT_FAILURE)
-    {
+  if (result == EXIT_FAILURE) {
       cmdline_parser_free (args_info);
-      exit (EXIT_FAILURE);
+    exit(EXIT_FAILURE);
     }
   
   return result;
